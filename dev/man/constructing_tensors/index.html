<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constructing tensors · Tensors.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Tensors.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Constructing tensors</a><ul class="internal"><li><a class="tocitem" href="#zero_tensors"><span>Zero tensors</span></a></li><li><a class="tocitem" href="#Constant-tensors"><span>Constant tensors</span></a></li><li><a class="tocitem" href="#Random-tensors"><span>Random tensors</span></a></li><li><a class="tocitem" href="#identity_tensors"><span>Identity tensors</span></a></li><li><a class="tocitem" href="#Base-vectors"><span>Base vectors</span></a></li><li><a class="tocitem" href="#From-arrays-/-tuples"><span>From arrays / tuples</span></a></li><li><a class="tocitem" href="#function_index"><span>From a function</span></a></li><li><a class="tocitem" href="#Diagonal-tensors"><span>Diagonal tensors</span></a></li><li><a class="tocitem" href="#Converting-to-tensors"><span>Converting to tensors</span></a></li></ul></li><li><a class="tocitem" href="../indexing/">Indexing</a></li><li><a class="tocitem" href="../binary_operators/">Binary Operations</a></li><li><a class="tocitem" href="../other_operators/">Other operators</a></li><li><a class="tocitem" href="../storing_tensors/">Storing tensors</a></li><li><a class="tocitem" href="../automatic_differentiation/">Automatic Differentiation</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../demos/">Demos</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Constructing tensors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constructing tensors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ferrite-FEM/Tensors.jl/blob/master/docs/src/man/constructing_tensors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Constructing-tensors"><a class="docs-heading-anchor" href="#Constructing-tensors">Constructing tensors</a><a id="Constructing-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-tensors" title="Permalink"></a></h1><p>Tensors can be created in multiple ways but they usually include running a function on tensor types of which there are two kinds, <code>Tensor{order, dim, T}</code> for non-symmetric tensors and <code>SymmetricTensor{order, dim, T}</code> for symmetric tensors. The parameter <code>order</code> is an integer of value 1, 2 or 4, excluding 1 for symmetric tensors. The second parameter <code>dim</code> is an integer which corresponds to the dimension of the tensor and can be 1, 2 or 3. The last parameter <code>T</code> is the number type that the tensors contain, i.e. <code>Float64</code> or <code>Float32</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Tensors.Tensor" href="#Tensors.Tensor"><code>Tensors.Tensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tensor{order,dim,T&lt;:Number}</code></pre><p>Tensor type supported for <code>order ∈ (1,2,4)</code> and <code>dim ∈ (1,2,3)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Tensor{1,3,Float64}((1.0, 2.0, 3.0))
3-element Vec{3, Float64}:
 1.0
 2.0
 3.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Tensors.SymmetricTensor" href="#Tensors.SymmetricTensor"><code>Tensors.SymmetricTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymmetricTensor{order,dim,T&lt;:Number}</code></pre><p>Symmetric tensor type supported for <code>order ∈ (2,4)</code> and <code>dim ∈ (1,2,3)</code>. <code>SymmetricTensor{4}</code> is a minor symmetric tensor, such that <code>A[i,j,k,l] == A[j,i,k,l]</code> and <code>A[i,j,k,l] == A[i,j,l,k]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SymmetricTensor{2,2,Float64}((1.0, 2.0, 3.0))
2×2 SymmetricTensor{2, 2, Float64, 3}:
 1.0  2.0
 2.0  3.0</code></pre></div></section></article><h2 id="zero_tensors"><a class="docs-heading-anchor" href="#zero_tensors">Zero tensors</a><a id="zero_tensors-1"></a><a class="docs-heading-anchor-permalink" href="#zero_tensors" title="Permalink"></a></h2><p>A tensor with only zeros is created using the function <code>zero</code>, applied to the type of tensor that should be created:</p><pre><code class="language-julia-repl hljs">julia&gt; zero(Tensor{1, 2})
2-element Vec{2, Float64}:
 0.0
 0.0</code></pre><p>By default, a tensor of <code>Float64</code>s is created, but by explicitly giving the <code>T</code> parameter this can be changed:</p><pre><code class="language-julia-repl hljs">julia&gt; zero(SymmetricTensor{4, 2, Float32})
2×2×2×2 SymmetricTensor{4, 2, Float32, 9}:
[:, :, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2] =
 0.0  0.0
 0.0  0.0</code></pre><p>A Julia <code>Array</code> with zeroed tensors can be created with <code>zeros</code>, with the tensor type and dimensions of the array as arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; zeros(Tensor{2,2}, 2, 3)
2×3 Matrix{Tensor{2, 2, Float64, 4}}:
 [0.0 0.0; 0.0 0.0]  [0.0 0.0; 0.0 0.0]  [0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0]  [0.0 0.0; 0.0 0.0]  [0.0 0.0; 0.0 0.0]</code></pre><h2 id="Constant-tensors"><a class="docs-heading-anchor" href="#Constant-tensors">Constant tensors</a><a id="Constant-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Constant-tensors" title="Permalink"></a></h2><p>A tensor filled with ones is created using the function <code>ones</code>, applied to the type of tensor that should be created:</p><pre><code class="language-julia-repl hljs">julia&gt; ones(Tensor{2,2})
2×2 Tensor{2, 2, Float64, 4}:
 1.0  1.0
 1.0  1.0</code></pre><p>By default, a tensor of <code>Float64</code>s is created, but by explicitly giving the <code>T</code> parameter this can be changed, like for <a href="#zero_tensors">zero</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function <code>ones</code> has double meaning: it can create a tensor filled with ones (as described above) or create a Julia <code>Array</code> with <a href="#identity_tensors">identity tensors</a>. Thus, to create an <code>Array</code> with tensors filled with ones, instead use array comprehension:</p><pre><code class="language-julia-repl hljs">julia&gt; [ones(Tensor{2,2}) for i in 1:2, j in 1:3]
2×3 Matrix{Tensor{2, 2, Float64, 4}}:
 [1.0 1.0; 1.0 1.0]  [1.0 1.0; 1.0 1.0]  [1.0 1.0; 1.0 1.0]
 [1.0 1.0; 1.0 1.0]  [1.0 1.0; 1.0 1.0]  [1.0 1.0; 1.0 1.0]</code></pre></div></div><h2 id="Random-tensors"><a class="docs-heading-anchor" href="#Random-tensors">Random tensors</a><a id="Random-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Random-tensors" title="Permalink"></a></h2><p>A tensor with random numbers is created using the function <code>rand</code>, applied to the type of tensor that should be created:</p><pre><code class="language-julia-repl hljs">julia&gt; rand(Tensor{2, 3})
3×3 Tensor{2, 3, Float64, 9}:
 0.590845  0.460085  0.200586
 0.766797  0.794026  0.298614
 0.566237  0.854147  0.246837</code></pre><p>By specifying the type, <code>T</code>, a tensor of different type can be obtained:</p><pre><code class="language-julia-repl hljs">julia&gt; rand(SymmetricTensor{2,3,Float32})
3×3 SymmetricTensor{2, 3, Float32, 6}:
 0.0107703  0.305865  0.2082
 0.305865   0.405684  0.257278
 0.2082     0.257278  0.958491</code></pre><h2 id="identity_tensors"><a class="docs-heading-anchor" href="#identity_tensors">Identity tensors</a><a id="identity_tensors-1"></a><a class="docs-heading-anchor-permalink" href="#identity_tensors" title="Permalink"></a></h2><p>Identity tensors can be created for orders 2 and 4. The components of the second order identity tensor <span>$\mathbf{I}$</span> are defined as <span>$I_{ij} = \delta_{ij}$</span>, where <span>$\delta_{ij}$</span> is the Kronecker delta. The fourth order identity tensor <span>$\mathsf{I}$</span> is the resulting tensor from taking the derivative of a second order tensor <span>$\mathbf{A}$</span> with itself:</p><p class="math-container">\[\mathsf{I} = \frac{\partial \mathbf{A}}{\partial \mathbf{A}} \Leftrightarrow I_{ijkl} = \frac{\partial A_{ij}}{\partial A_{kl}} = \delta_{ik} \delta_{jl}.\]</p><p>The symmetric fourth order tensor, <span>$\mathsf{I}^\text{sym}$</span>, is the resulting tensor from taking the derivative of a symmetric second order tensor <span>$\mathbf{A}^\text{sym}$</span> with itself:</p><p class="math-container">\[\mathsf{I}^\text{sym} = \frac{\partial \mathbf{A}^\text{sym}}{\partial \mathbf{A}^\text{sym}} \Leftrightarrow I^\text{sym}_{ijkl} = \frac{\partial A^\text{sym}_{ij}}{\partial A^\text{sym}_{kl}} = \frac{1}{2} (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}).\]</p><p>Identity tensors are created using the function <code>one</code>, applied to the type of tensor that should be created:</p><pre><code class="language-julia-repl hljs">julia&gt; one(SymmetricTensor{2, 2})
2×2 SymmetricTensor{2, 2, Float64, 3}:
 1.0  0.0
 0.0  1.0</code></pre><p>A Julia <code>Array</code> with identity tensors can be created with <code>ones</code>, with the tensor type and dimensions of the array as arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; ones(Tensor{2,2}, 2, 2)
2×2 Matrix{Tensor{2, 2, Float64, 4}}:
 [1.0 0.0; 0.0 1.0]  [1.0 0.0; 0.0 1.0]
 [1.0 0.0; 0.0 1.0]  [1.0 0.0; 0.0 1.0]</code></pre><h2 id="Base-vectors"><a class="docs-heading-anchor" href="#Base-vectors">Base vectors</a><a id="Base-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Base-vectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Tensors.basevec" href="#Tensors.basevec"><code>Tensors.basevec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basevec(::Type{Vec{dim, T}})
basevec(::Type{Vec{dim, T}}, i)
basevec(::Vec{dim, T})
basevec(::Vec{dim, T}, i)</code></pre><p>Return a tuple with the base vectors corresponding to the dimension <code>dim</code> and type <code>T</code>. An optional integer <code>i</code> can be used to extract the i:th base vector. The alias <code>eᵢ</code> can also be used, written <code>e\_i&lt;TAB&gt;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eᵢ(Vec{2, Float64})
([1.0, 0.0], [0.0, 1.0])

julia&gt; eᵢ(Vec{2, Float64}, 2)
2-element Vec{2, Float64}:
 0.0
 1.0</code></pre></div></section></article><h2 id="From-arrays-/-tuples"><a class="docs-heading-anchor" href="#From-arrays-/-tuples">From arrays / tuples</a><a id="From-arrays-/-tuples-1"></a><a class="docs-heading-anchor-permalink" href="#From-arrays-/-tuples" title="Permalink"></a></h2><p>Tensors can also be created from a tuple or an array with the same number of elements as the number of independent indices in the tensor. For example, a first order tensor (vector) in two dimensions is here created from a vector of length two:</p><pre><code class="language-julia-repl hljs">julia&gt; Tensor{1,2}([1.0,2.0])
2-element Vec{2, Float64}:
 1.0
 2.0</code></pre><p>Below, a second order symmetric tensor in two dimensions is created from a tuple. Since the number of independent indices in this tensor is three, the length of the tuple is also three. For symmetric tensors, the order of the numbers in the input tuple is column by column, starting at the diagonal.</p><pre><code class="language-julia-repl hljs">julia&gt; SymmetricTensor{2,2}((1.0,2.0,3.0))
2×2 SymmetricTensor{2, 2, Float64, 3}:
 1.0  2.0
 2.0  3.0</code></pre><h2 id="function_index"><a class="docs-heading-anchor" href="#function_index">From a function</a><a id="function_index-1"></a><a class="docs-heading-anchor-permalink" href="#function_index" title="Permalink"></a></h2><p>A tensor can be created from a function <code>f(indices...) -&gt; v</code> which maps a set of indices to a value. The number of arguments of the function should be equal to the order of the tensor.</p><pre><code class="language-julia-repl hljs">julia&gt; SymmetricTensor{2,2,Float64}((i,j) -&gt; i + j)
2×2 SymmetricTensor{2, 2, Float64, 3}:
 2.0  3.0
 3.0  4.0</code></pre><p>For symmetric tensors, the function is only called for the lower triangular part.</p><h2 id="Diagonal-tensors"><a class="docs-heading-anchor" href="#Diagonal-tensors">Diagonal tensors</a><a id="Diagonal-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-tensors" title="Permalink"></a></h2><p>A diagonal second order tensor can be created by either giving a number or a vector that should appear on the diagonal:</p><pre><code class="language-julia-repl hljs">julia&gt; diagm(Tensor{2,2}, 2.0)
2×2 Tensor{2, 2, Float64, 4}:
 2.0  0.0
 0.0  2.0

julia&gt; diagm(SymmetricTensor{2,3}, [1.0, 2.0, 3.0])
3×3 SymmetricTensor{2, 3, Float64, 6}:
 1.0  0.0  0.0
 0.0  2.0  0.0
 0.0  0.0  3.0</code></pre><h2 id="Converting-to-tensors"><a class="docs-heading-anchor" href="#Converting-to-tensors">Converting to tensors</a><a id="Converting-to-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-to-tensors" title="Permalink"></a></h2><p>Sometimes it is necessary to convert between standard Julia <code>Array</code>&#39;s and <code>Tensor</code>&#39;s. When the number type is a bits type (like for floats or integers) this is conveniently done by the <code>reinterpret</code> function. For example, a <code>2×5</code> Julia <code>Array</code> can be translated to a vector of <code>Vec{2}</code> with the following code</p><pre><code class="language-julia-repl hljs">julia&gt; data = rand(2, 5)
2×5 Matrix{Float64}:
 0.590845  0.566237  0.794026  0.200586  0.246837
 0.766797  0.460085  0.854147  0.298614  0.579672

julia&gt; tensor_data = reinterpret(Vec{2, Float64}, vec(data))
5-element reinterpret(Vec{2, Float64}, ::Vector{Float64}):
 [0.5908446386657102, 0.7667970365022592]
 [0.5662374165061859, 0.4600853424625171]
 [0.7940257103317943, 0.8541465903790502]
 [0.20058603493384108, 0.2986142783434118]
 [0.24683718661000897, 0.5796722333690416]</code></pre><p>The data can also be reinterpreted back to a Julia <code>Array</code></p><pre><code class="language-julia-repl hljs">julia&gt; data = reshape(reinterpret(Float64, tensor_data), (2, 5))
2×5 Matrix{Float64}:
 0.590845  0.566237  0.794026  0.200586  0.246837
 0.766797  0.460085  0.854147  0.298614  0.579672</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../indexing/">Indexing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 4 August 2023 09:55">Friday 4 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
